//////////////////////////////////////////////////
// Universidade Federal de Pernambuco - UFPE	//	  
// Residência Tecnológica em Software Automotivo//      			  
// Final Project -  Team 1                      //
//////////////////////////////////////////////////

/*
	This ECU is called the simulation ECU, whose main function is to simulate the enviroment where the system would be operating.
	Since we do not have the means to peform hardware tests or live tests, this ECU will generate data based on mathematical model.
	Thus, the data that would be measured is generated by the simulation and sent on CAN bus to be received by the other ECUs.
	It also receives data, the calculated ACC acceleration, from the ACC ECU to be used on simulation and thus, generating new data for 
	the next iteraction.
*/



#include <stdbool.h>
#include "Arduino.h"
#include "mcp_can.h"

//ID CAN Receive. Used to detect the Ego acceleration CAN message ID, sent by ACC ECU
#define Ego_acceleration_ID	0x0D4001B0 

//ID CAN send. Used to build CAN message frame to be sent on the CAN bus.
#define EV_RV_RD_data_ID    0x0C1B3049 

//Macros send
#define DLC			8
#define EXT_FRAME 	1

//Variables received CAN Frame
unsigned char     mDATA[8];     //Used to store DATA received from the CAN bus. Represents the CAN data field.
unsigned char     mDLC     = 0; //Represents the number of bytes present in the received data field.
long unsigned int mID      = 0; //Used to store, compare and/or write on ID field (CAN message frame).

static            byte M = 0; //You can use it to check the status of the CAN message. If M == CAN_OK, the message was transmitted successfully.

//Definition of receive buffer size for CAN MCP 2515 module. It has a limit of reception and transmit buffers.
//Check datasheet for more details
#define BUFF_MAX 	10
#define BUFF_MIN 	00
volatile int		buffer = BUFF_MAX;

//Variables send by CAN network
float Ego_speed  			 = 60.0/3.6;  //Initial ego car position  (m/s)
float Relative_speed    	 = 0;		
float Relative_distance_pres = 10;

//Variables received by CAN network
float Ego_acceleration	= 0;

//Environment variables
float Lead_acceleration = 0;		 //Initial lead car acceleration (m/s^2).
float Lead_position     = 50.0;      //Initial lead car position (m)
float Ego_position      = 10.0;      //Initial ego car position  (m)
float Lead_speed 		= 55.0/3.6;  //Initial lead car position (m/s)
float interval  		= 0.01;      //Interval (dt) between iteractions.
//int   counter   		= 0; 		//Number of iteractions.
float Relative_distance_past = 0;  	//The previous' iteraction relative distance
unsigned long timePrevious 	 = 0;  	//Time mark from the previous iteraction. 
unsigned long timeCurrent 	 = 0;	//Time mark for the current iteraction.
unsigned long timeVariation  = 0;	//Difference between marked times between iteractions
const float Lead_acceleration_min  = -1; //Maximum brake value on m/s^2 for lead car
const float Lead_acceleration_max  = 1;//Maximum acceleration allowed for the Lead, in m/s^2


//Variables to store CAN data to be sent. Used to build the "data" field.
char  Ego_Speed_send[4];
char  Relative_Speed_send[4];
char  Relative_distance_pres_send[4];

//CAN FRAME_DATA START 
unsigned char Send_data[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

//MPC_CAN Object with Chip selector as digital pin 10
MCP_CAN CAN1(10);

void setup() 
{
	//Starting the initial values
	float Relative_distance_pres = Lead_position - Ego_position;   //Relative distance between Ego and Lead Car.
	float Relative_distance_past = Relative_distance_pres; 		   //Past value of relative distance.
	
	Serial.begin(115200);
	
	//Start CAN controller : baudrate = 250K, clock=8MHz
	while (CAN1.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) != CAN_OK) {
        delay(200);        
    }
	//Serial.println("MCP2515 can_send Started!");
	//Defines operation mode
	CAN1.setMode(MCP_NORMAL); //Defines operation mode.
	pinMode(2, INPUT); //Defines digital pin 2 as input.
	
}

void loop()
{
	timeCurrent = millis(); //Time mark.
	timeVariation = timeCurrent-timePrevious; //Time variation.
  
	if (timeVariation >= 10){ //Used to control the frequency in which both the CAN bus and the simulation are used. (milliseconds)
		
		if(!digitalRead(2)){
			CAN1.readMsgBuf(&mID, &mDLC, mDATA);
			if((mID & Ego_acceleration_ID) == Ego_acceleration_ID){
				Ego_acceleration = (mDATA[1] << 8) | mDATA[2];
				Ego_acceleration = (Ego_acceleration-5)*0.01;
			}else{
				Ego_acceleration = Ego_acceleration;
			}
		}
		
		if (Serial.available() > 0){ // Verifica se há dados disponíveis na porta serial
			Lead_acceleration = Serial.parseFloat();  // Lê o valor recebido da porta serial
			Lead_acceleration = (Lead_acceleration < Lead_acceleration_min) ? Lead_acceleration_min : (Lead_acceleration > Lead_acceleration_max) ? Lead_acceleration_max:Lead_acceleration;
		}
		Serial.read();
	
		Relative_distance_past = Relative_distance_pres; //Storage of the last value of Relative Distance
	
		//Simulation of vehicles behavior
		Ego_speed = Ego_speed + interval*Ego_acceleration;
		
		Lead_speed = Lead_speed + interval*Lead_acceleration;

		//Calculation of Ego Car position
		Ego_position += (Ego_speed*interval);

		//Calculation of Lead Car position
		Lead_position += (Lead_speed*interval);

		Relative_distance_pres = Lead_position - Ego_position;
		Relative_speed = Lead_speed - Ego_speed;

		if(Relative_distance_pres > 200){
			Relative_distance_pres = 200;
		}else{
			Relative_distance_pres = Relative_distance_pres;
		}
		
		timePrevious = timeCurrent;
		
		//Prints on serial the values for that simulation.
		//In this format, It is possible to use the arduino IDE to generate a graph in "plotter" option.
		Serial.print("Ego_acceleration:");
		Serial.print(Ego_acceleration);
		Serial.print(",");
	
		Serial.print("Relative Distance:");
		Serial.print(Relative_distance_pres);
		Serial.print(",");
		
		Serial.print("EGO SPEED:");
		Serial.print(Ego_speed);
		Serial.print(",");

		Serial.print("LEAD SPEED:");
		Serial.print(Lead_speed);
		Serial.print(",");

		Serial.print("Rspeed:");
		Serial.println(Relative_speed);
		
		//It separates the bytes and allocates them within the CAN message to be sent.
		sprintf(Ego_Speed_send , "%04X", (int)(Ego_speed*256));
		Send_data[1] = strtol(Ego_Speed_send , NULL, 16) >> 8;
		Send_data[2] = strtol(Ego_Speed_send  + 2, NULL, 16);
		//It separates the bytes and allocates them within the CAN message to be sent.
		sprintf(Relative_distance_pres_send , "%04X", (int)Relative_distance_pres);
		Send_data[3] = strtol(Relative_distance_pres_send , NULL, 16) >> 8;
		Send_data[4] = strtol(Relative_distance_pres_send  + 2, NULL, 16);
		//It separates the bytes and allocates them within the CAN message to be sent.
		sprintf(Relative_Speed_send , "%04X", (int)(Relative_speed*256));
		Send_data[5] = strtol(Relative_Speed_send , NULL, 16) >> 8;
		Send_data[6] = strtol(Relative_Speed_send  + 2, NULL, 16);
		//Send the CAN message
		M = CAN1.sendMsgBuf(EV_RV_RD_data_ID,EXT_FRAME,DLC,Send_data);
	}	
}
